<!DOCTYPE html>
<html lang="eu">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta name="description" content="A webgl wrapper for the nim programming language">
  <meta name="author" content="stisa">
   <link rel="stylesheet" href="http://stisa.space/css/main.css">
  <link rel="stylesheet" href="http://stisa.space/css/prism.css">
  <link rel="apple-touch-icon-precomposed" href="http://stisa.space/favicon-152.png">
  <meta name="msapplication-TileColor" content="#FFFFFF">
  <meta name="msapplication-TileImage" content="http://stisa.space/favicon-144.png">
  <style>@media only screen and (min-width: 800px)  { .output { float:left; padding-right:1em;} .content {max-width:82%;} } </style>
  <title>Example 3</title>
</head>
<body>
  <header class="sidebar">

    <h3>Menu</h3>

    <div class="menu">

      <a href="/">Home</a>
      <a href="/projects/">Projects</a>
      <a href="/about/">About Me</a>
      <br/>
      <a href="/webgl/">Webgl</a>
      <a href="https://bitbucket.org/runhello/nim-webgl-test">Original Code</a>
    </div>
   
  </header>
  <section class="content">
    <section class="output" id="output">
      
      <h2>Example 3</h2>
      <canvas id="canvas" width="640" height="480">
        Your browser doesn't appear to support the 
        <code>&lt;canvas&gt;</code> element.
      </canvas>
      <script src="./ex3.js"></script>
    </section>
    <section class="examplecode">
      <h2>Code</h2>
      <pre><code class="language-nim">import dom,../webgl,math

#utils

proc initWebGL(canvas:webgl.Canvas): WebGLRenderingContext {.inline.} = webgl.getContextWebGL(canvas)

proc checkShader(gl:WebGLRenderingContext,shader:WebGLShader) = 
  if not gl.getStatus(shader): log gl.getShaderInfoLog(shader)
proc checkProgram(gl:WebGLRenderingContext,prog:WebGLProgram) =
  if not gl.getStatus(prog): log gl.getProgramInfoLog(prog)  

let x = [1,2,3]
var y = x
var z = x
y[0] = 10

const
  startX = [-0.75,  0.75, -0.75,  0.75]
  startY = [-0.75, -0.75,  0.75,  0.75]
  freqs =  [1.0, math.pow(2.0, 1.0/4.0), math.pow(2.0, 1.0/3.0), math.pow(2.0, 1.0/2.0)]

var
  modelX = startX
  modelY = startY

# Form an X out of the four points described above
proc makeModel() : seq[float] =
  return @[
    modelX[0], modelY[0], modelX[1], modelY[1],
    modelX[0], modelY[0], modelX[2], modelY[2],
    modelX[0], modelY[0], modelX[3], modelY[3],
    modelX[1], modelY[1], modelX[3], modelY[3],
    modelX[2], modelY[2], modelX[1], modelY[1],
    modelX[2], modelY[2], modelX[3], modelY[3]
  ]

# Shaders

let vertexShaderCode = """
attribute vec2 position;
void main(void) {
    gl_Position = vec4(position, 0.0, 1.0);
}
"""

let fragmentShaderCode = """
void main(void) {
    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
}
"""

# Create context
var canv = dom.document.getElementById("canvas").Canvas
var gl = initWebGL(canv)

# Create a model
var packedModel = newSeq[float](makeModel().len)# newFloat32Array(makeModel().len.float)
var vertices = gl.createBuffer()

# Create vertex shader
var vertexShader = gl.createShader(webgl.VERTEX_SHADER)
gl.shaderSource(vertexShader, vertexShaderCode)
gl.compileShader(vertexShader)
gl.checkShader(vertexShader)

# Create fragment shader
var fragmentShader = gl.createShader(webgl.FRAGMENT_SHADER)
gl.shaderSource(fragmentShader, fragmentShaderCode)
gl.compileShader(fragmentShader)
gl.checkShader(fragmentShader)

# Link program
var program = gl.createProgram()
gl.attachShader(program, vertexShader)
gl.attachShader(program, fragmentShader)
gl.linkProgram(program)
gl.checkProgram(program)

var positionAttrib = gl.getAttribLocation(program, "position")

var theta:float = 0.0

proc draw(gl:WebGLRenderingContext)=
    let bg = (cos(theta)+1.0)/2.0 # Pulsate background on timer

    # Upload values for model
    let model = makeModel()
    packedModel = model
    #for i in 0..&ltmodel.len:
    #    float32Set(packedModel, i.float, model[i])
    gl.bindBuffer(webgl.ARRAY_BUFFER, vertices)
    gl.bufferData(webgl.ARRAY_BUFFER, packedModel, webgl.DYNAMIC_DRAW)
    gl.bindBuffer(webgl.ARRAY_BUFFER, nil)

    # Set display properties and clear screen
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height)
    gl.clearColor(bg, 0.0, 0.0, 1.0)
    gl.enable(webgl.DEPTH_TEST)
    gl.depthFunc(webgl.LEQUAL) # Near things obscure far things
    gl.clear(webgl.COLOR_BUFFER_BIT or webgl.DEPTH_BUFFER_BIT)

    # Set up draw
    gl.useProgram(program)
    gl.bindBuffer(webgl.ARRAY_BUFFER, vertices)
    gl.vertexAttribPointer(positionAttrib, 2, webgl.FLOAT, false, 0, 0)
    gl.enableVertexAttribArray(positionAttrib)

    # Draw
    gl.drawArrays(webgl.LINES, 0, (model.len div 2) )

    # State updates: do a silly, trivial animation.
    # Wobble each of the four anchors for the model at a slightly different rate.
    theta += PI/512.0
    for i in 0..&ltstartX.len:
        let at = theta*8-(i*4+1).float*PI
        if at > 0: # Start each anchor wobbling at a different time (one every three base wobbles)
            modelX[i] = startX[i] + sin(at * freqs[i])/8.0

proc animLoop() =
   draw(gl)
   {.emit: "window.requestAnimationFrame(`animLoop`);" .}

# Init
if gl != nil:
  draw(gl)
  animLoop()
</code></pre>
    </section>
  </section>
  <script src="http://stisa.space/js/prism.js"></script>

</body>

</html>